from io import BufferedReader, FileIO
from pathlib import Path
from typing import TYPE_CHECKING, Any, BinaryIO, Dict, Generator, List, Optional, Tuple, Union
from typing_extensions import Literal, TypeAlias, get_args

from e621.autogenerated_models import PostFlag

from ..session import SimpleSession
from ..models import EnrichedPost
from .endpoints import BaseEndpoint

if TYPE_CHECKING:
    from ..api import E621API

Rating: TypeAlias = Literal["s", "q", "e"]
HttpUrl: TypeAlias = str


class Posts(BaseEndpoint):
    def get(self, post_id: int) -> EnrichedPost:
        return EnrichedPost.from_response(self._api.session.get(f"posts/{post_id}"), expect=dict)

    def list(
        self,
        tags: str = "",
        limit: Optional[int] = None,
        page: int = 1,
        ignore_pagination: bool = False,
    ) -> List[EnrichedPost]:
        return _list_posts(self._api, "posts", {"tags": tags, "limit": limit, "page": page}, ignore_pagination)

    def create(
        self,
        tag_string: str,
        file: Union[Path, FileIO, HttpUrl],
        rating: Rating,
        sources: List[HttpUrl],
        description: str,
        parent_id: Optional[int] = None,
        referer_url: Optional[HttpUrl] = None,
        md5_confirmation: Optional[str] = None,
        as_pending: bool = False,
    ) -> EnrichedPost:
        params = {
            "upload[tag_string]": tag_string,
            "upload[rating]": rating,
            "upload[sources]": ",".join(sources),
            "upload[description]": description,
            "upload[parent_id]": parent_id,
            "upload[referer_url]": referer_url,
            "upload[md5_confirmation]": md5_confirmation,
            "upload[as_pending]": as_pending,
        }
        files = {}
        if isinstance(file, Path):
            files["upload[file]"] = file.open("rb")
        elif isinstance(file, BinaryIO):
            files["upload[file]"] = file
        elif isinstance(file, HttpUrl):
            params["upload[direct_url]"] = file
        r = self._api.session.post("posts", params=params, files=files)

        return self.get(r.json()["post_id"])

    def update(
        self,
        post_id: int,
        tag_string_diff: Optional[str] = None,
        source_diff=None,
        parent_id=None,
        old_parent_id=None,
        description=None,
        old_description=None,
        rating=None,
        old_rating=None,
        is_rating_locked=None,
        is_note_locked=None,
        edit_reason=None,
        has_embedded_notes: Optional[bool] = None,
    ) -> None:
        self._api.session.patch(
            f"posts/{post_id}",
            params={
                "post[tag_string_diff]": tag_string_diff,
                "post[source_diff]": source_diff,
                "post[parent_id]": parent_id,
                "post[old_parent_id]": old_parent_id,
                "post[description]": description,
                "post[old_description]": old_description,
                "post[rating]": rating,
                "post[old_rating]": old_rating,
                "post[is_rating_locked]": is_rating_locked,
                "post[is_note_locked]": is_note_locked,
                "post[edit_reason]": edit_reason,
                "post[has_embedded_notes]": has_embedded_notes,
            },
        )
        """
        post[tag_string_diff] A space delimited list of tag changes such as dog -cat. This is a much preferred method over the old version.
        (The old method of updating a post’s tags still works, with post[old_tag_string] and post[tag_string], but post[tag_string_diff] is preferred.)

        post[source_diff] A (URL encoded) newline delimited list of source changes. This works the same as post[tag_string_diff] but with sources.
        (The old method of updating a post’s sources still works, with post[old_source] and post[source], but post[source_diff] is preferred.)

        post[parent_id] The ID of the parent post.
        post[old_parent_id] The ID of the previously parented post.
        post[description] This will be used as the post's 'Description' text.
        post[old_description] Should include the same descriptions submitted to post[description] minus any intended changes.
        post[rating] The rating for the post. Can be: s, q or e for safe, questionable, and explicit respectively.
        post[old_rating] The previous post’s rating.
        post[is_rating_locked] Set to true to prevent others from changing the rating.
        post[is_note_locked] Set to true to prevent others from adding notes.
        post[edit_reason] The reason for the submitted changes. Inline DText allowed.
        post[has_embedded_notes] (True/False)
        """


class Favorites(BaseEndpoint):
    def list(self, user_id: Optional[int] = None, limit: Optional[int] = None, page: int = 1) -> List[EnrichedPost]:
        return _list_posts(self._api, "favorites", {"user_id": user_id, "limit": limit, "page": page})

    def create(self, post_id: int) -> EnrichedPost:
        return EnrichedPost.from_response(self._api.session.post("favorites", params={"post_id": post_id}), expect=dict)

    def delete(self, post_id: int) -> None:
        self._api.session.delete(f"favorites/{post_id}")


class PostFlags(BaseEndpoint):
    def list(
        self,
        post_id: Optional[int] = None,
        creator_id: Optional[int] = None,
        creator_name: Optional[str] = None,
    ) -> List[PostFlag]:
        params = {
            "search[post_id]": post_id,
            "search[creator_id]": creator_id,
            "search[creator_name]": creator_name,
        }
        return PostFlag.from_response(self._api.session.get("post_flags", params=params), expect=list)

    def create(self, post_id: int, reason_name: str, parent_id: Optional[int] = None) -> PostFlag:
        if reason_name == "inferior" and parent_id is None:
            raise ValueError
        params = {
            "post_flag[post_id]": post_id,
            "post_flag[reason_name]": reason_name,
            "post_flag[parent_id]": parent_id,
        }
        return PostFlag.from_response(self._api.session.post("post_flags", params=params), expect=dict)


def _list_posts(
    api: "E621API",
    endpoint_name: str,
    params: Dict[str, Any],
    ignore_pagination: bool = False,
) -> List[EnrichedPost]:
    if ignore_pagination:
        posts = EnrichedPost.from_list(api.session.paginated_get(endpoint_name, params, root_entity_name="posts"))
    else:
        posts = EnrichedPost.from_response(api.session.get(endpoint_name, params=params), expect=list)
    # FIXME: this works with single tag on the blacklist but e621 supports tag groups in blacklists
    # FIXME: this works if the person put the tag correctly, but doesn't work with tag aliases
    return [p for p in posts if not p.all_tags & api.blacklist]
